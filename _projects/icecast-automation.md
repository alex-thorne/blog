---
layout: project
title: 'Icecast Automation'
caption: Beginner accessible self-hosted internet radio
description: >
  Automation to deploy and configure [Icecast](https://icecast.org/). Intended as a) a quick-start guide to support small internet-radio communities launching their own Icecast setups, and b) an initial baseline to port over to the PCE Radio to automate our own internet radio deployment.
date: '05-02-2025'
accent_color: '#4fb1ba'
# accent_image:
#   background: '#ffffff'
#   theme_color: '#ffffff'
image: 
  path: /assets/img/projects/icecastrepo.jpg
  srcset: 
    1920w: /assets/img/projects/icecastrepo.jpg
    960w:  /assets/img/projects/icecastrepo@0,5x.jpg
    480w:  /assets/img/projects/icecastrepo@0,25x.jpg
links:
  - title: GitHub Link 
    url: https://github.com/alex-thorne/icecast.automation
sitemap: false
---

# Icecast Automation

Surely you've heard of the massive juggernaut of internet radio, the [Porkchop Express](http://porkchopexpress.live/), (or "PCE" as we call it). This project was a quick launchpad to prepare for updating our deployment approach for the PCE. And when I say "deployment approach," I mean one person having manually configured an icecast server on an ubuntu Digital Ocean droplet 5 years ago.

_Community_ is really the main goal of the PCE. Playing and discussing music online is the primary way the people of the PCE get together, but the development of the site and the infrastructure that makes it possible is another cool medium for community engagement. Making sure we have an ability to quickly and easily deploy the site is a crucial step in allowing others to make changes.

## Background

The primary component of PCE is an [Icecast](https://icecast.org/) server which allows our radio DJs to broadcast a stream from their local sound source which our listeners can connect to. There is an [nginx](https://nginx.org/en/) server in front of it, acting as a reverse proxy and presenting the simply static website generated by [Jekyll](https://jekyllrb.com/). That's it. It's simple! So simple anyone could do it. I tried to keep this first iteration of this project, this public repository, to the simplest form required to get an Icecast instance up and running and connect to it; just the mandatory components. Porting over the delivery automation to the our PCE and further building it out to fit its specifics is step 2. The project is therefore just an Icecast server and an nginx server. PCE is running on to [Digital Ocean](https://www.digitalocean.com/0), so I built the project to do so as well. The droplets are provisioned via Terraform, and the services deployed and configured via Ansible.

### Terraform

The Terraform setup is simple here, no bells or whistles really. It creates:

- A single Ubuntu 22.04 droplet with minimal specs (1GB RAM, 1 CPU)
- A firewall allowing HTTP (80), and Icecast (8000) traffic
- DNS records pointing to the droplet

There is a simple "dynamic" inventory setup that populates the ansible inventory from the IP addresses reported in the `output` when applying the Terraform plan.

```terraform
resource "local_file" "ansible_inventory" {
  content = templatefile("${path.module}/inventory.tmpl",
    {
      icecast_ip = digitalocean_droplet.icecast.ipv4_address
      nginx_ip = digitalocean_droplet.nginx.ipv4_address
    }
  )
  filename = "${path.module}/../ansible/inventory"
}
```

### Ansible

The Ansible playbook handles the installation and configuration of icecast2 on one droplet, and nginx on a second.

The icecast2 setup includes some slightly interesting jinja templating which allows for multiple listening sockets, mountpoints to be configured via a `vars` file in the role path:

{% raw %}
```jinja
{% for listen_socket in icecast_listen_sockets %}
  <listen-socket>
  {% for key, value in listen_socket.items() %}
    {% if key in ['port', 'bind-address', 'ssl', 'shoutcast-mount', 'shoutcast-compat'] %}
    <{{ key }}>{{ value }}</{{ key }}>
    {% endif %}
  {% endfor %}
  </listen-socket>
{% endfor %}

{% if icecast_http_headers is defined %}
  <http-headers>
  {% for http_header in icecast_http_headers %}
    <header name="{{ http_header['name'] }}" value="{{ http_header['value'] }}"{% if http_header['status'] is defined %} status="{{ http_header['status'] }}" {% endif %} />
  {% endfor %}
  </http-headers>
{% endif %}

{% if icecast_mounts is defined %}
  {% for mount in icecast_mounts %}
  <mount type="{{ mount['type'] | default('normal') }}">
    {% for key, value in mount.items() %}
      {% if key in ['mount-name', 'username', 'password', 'max-listeners', 'dump-file', 'intro',
        'fallback-mount', 'fallback-override', 'fallback-when-full', 'charset', 
        'public', 'stream-name', 'stream-description', 'stream-url', 'genre', 
        'bitrate', 'subtype', 'hidden', 'burst-size',
        'mp3-metadata-interval', 'authentication', 'http-headers', 'on-connect', 
        'on-disconnect'] %}
    <{{ key }}>{{ value }}</{{ key }}>
      {% endif %}
    {% endfor %}
  </mount>
  {% endfor %}
{% endif %}
```
{% endraw %}

The Nginx reverse proxy is also pretty straightforward, with some of its own templating to add the addresses from the populated Ansible inventory:

{% raw %}
```jinja
# Main stream location
location /live {
    proxy_pass http://{{ hostvars['icecast'].ansible_host }}:8000/live;
    add_header Cache-Control no-cache;
    # Debug headers
    add_header X-Debug-Target "{{ hostvars['icecast'].ansible_host }}:8000/live" always;
    add_header X-Debug-Host $host always;

```
{% endraw %}

It also configures a very basic landing page to allow some basic debugging:

<picture>
  <source srcset="/assets/img/projects/icecastauto-simplefrontend@12.5.png" media="(max-width: 240px)">
  <source srcset="/assets/img/projects/icecastauto-simplefrontend@25.png" media="(max-width: 480px)">
  <source srcset="/assets/img/projects/icecastauto-simplefrontend@50.png" media="(max-width: 960px)">
  <source srcset="/assets/img/projects/icecastauto-simplefrontend.png" media="(max-width: 1920px)">
  <img src="/assets/img/projects/icecastauto-simplefrontend.png" alt="simple 'front end'">
</picture>

### Project Details
- Date started: 01-02-2025
- GitHub: [icecast.automation](https://github.com/alex-thorne/icecast.automation)